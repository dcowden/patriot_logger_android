package com.patriotlogger.logger.data;

import androidx.lifecycle.LiveData;
import androidx.room.Dao;
import androidx.room.Insert;
import androidx.room.OnConflictStrategy; // Keep this if used by insert/update
import androidx.room.Query;
import androidx.room.Update;
import android.util.Log;
import java.util.List;

@Dao
public interface TagStatusDao {

    // --- Write Operations (Synchronous - to be called from Repository's background executor) ---
    @Insert
    long insertSync(TagStatus tagStatus);

    @Update
    void updateSync(TagStatus tagStatus);

    // This default upsert will be called by Repository's upsertTagStatus,
    // which is already on a background thread.
    default void upsert(TagStatus tagStatus) {
        if (tagStatus.trackId == 0) {
            // Since insertSync returns the new row ID (which is the trackId if it's an autogenerated PK)
            // and assuming trackId is your primary key and auto-generated by Room on insert if 0.
            // If trackId is not auto-generated or you want to set it before insert,
            // this logic might need adjustment based on your Entity definition.
            // For now, assuming insertSync handles setting the ID if it was 0.
            long newTrackId = insertSync(tagStatus);
            if (tagStatus.trackId == 0) { // If it was truly an insert that auto-generated ID
                tagStatus.trackId = (int) newTrackId; // Update the object in memory if needed by caller
            }
        } else {
            updateSync(tagStatus);
        }
    }

    // This default upsertSync will be called by Repository's upsertTagStatus (with callback),
    // which is already on a background thread.
    default long upsertSync(TagStatus tagStatus) {
        if (tagStatus.trackId == 0) {
            long s = System.currentTimeMillis();

            Log.d("TagStatusDao", "Insert existing with trackId: " + tagStatus.trackId + ", lastSeenMs=" + tagStatus.lastSeenMs+ " dt=" +  (System.currentTimeMillis() - s));
            long r =  insertSync(tagStatus); // Returns the new rowId (which should be trackId)
            Log.d("TagStatusDao", "Done");
            return r;
        } else {

            long s = System.currentTimeMillis();
            updateSync(tagStatus);
            Log.d("TagStatusDao", "Updating existing TagStatus with trackId: " + tagStatus.trackId + ", lastSeenMs=" + tagStatus.lastSeenMs + " dt=" +  (System.currentTimeMillis() - s));
            long r = tagStatus.trackId; // Return existing trackId on update
            Log.d("TagStatusDao", "Done");
            return r;
        }
    }

    @Query("DELETE FROM tag_status")
    void clear();


    // --- Read Operations (Returning LiveData - Room handles background execution) ---
    @Query("SELECT COUNT(*) from tag_status;")
    LiveData<Integer> getStatusSampleCount();

    @Query("SELECT * FROM tag_status ORDER BY trackId DESC")
    LiveData<List<TagStatus>> liveAll(); // You already had this - good!

    @Query("SELECT * FROM tag_status WHERE trackId = :trackId LIMIT 1")
    LiveData<TagStatus> liveGetByTrackId(int trackId); // NEW: LiveData version

    @Query("SELECT * FROM tag_status WHERE tagId = :tagId AND (state = 'APPROACHING' OR state = 'HERE') ORDER BY trackId DESC LIMIT 1")
    LiveData<TagStatus> liveGetActiveStatusForTagId(int tagId); // NEW: LiveData version

    // Note: Room handles List<String> for IN clauses correctly.
    // This will return a LiveData list, usually containing 0 or 1 item if your UI expects a single status.
    // If you always expect one or zero, consider wrapping this in the Repository or ViewModel
    // to extract the first element or provide a LiveData<TagStatus>.
    // For direct DAO, LiveData<List<TagStatus>> is fine.
    @Query("SELECT * FROM tag_status WHERE tagId = :tagId AND state IN (:states) ORDER BY trackId DESC")
    LiveData<List<TagStatus>> liveGetByTagIdAndStates(int tagId, List<String> states);

    @Query("SELECT * FROM tag_status ORDER BY trackId DESC")
    List<TagStatus> getAllSync();

    @Query("SELECT * FROM tag_status WHERE trackId = :trackId LIMIT 1")
    TagStatus getByTrackIdSync(int trackId);

    //@Query("SELECT * FROM tag_status WHERE tagId = :tagId AND (state = 'APPROACHING' OR state = 'HERE') ORDER BY trackId DESC LIMIT 1")
    //TagStatus getActiveStatusForTagIdSync(int tagId);

    @Query("SELECT * FROM tag_status WHERE tagId = :tagId AND (state = 'LOGGED' ) ORDER BY trackId DESC LIMIT 1")
    TagStatus getTagStatusForTagId(int tagId);


    @Query("SELECT * FROM tag_status WHERE tagId = :tagId AND state IN (:states) ORDER BY trackId DESC")
    List<TagStatus> getByTagIdAndStatesSync(int tagId, List<String> states);



}
